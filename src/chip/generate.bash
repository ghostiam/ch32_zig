#!/usr/bin/env bash

CHIP_LIST_URL="https://www.wch-ic.com/api/product_tables/47?page=1&limit=100"
OUTPUT_FILE="model.zig"

curl $CHIP_LIST_URL -o chip-list.json

cat <<EOF >"$OUTPUT_FILE"
/// This file is generated by template/chip/generate.bash. DO NOT EDIT.
const std = @import("std");
const Series = @import("series.zig").Series;

pub const Class = enum {
    none,
    d6,
    d8,
    d8c,
    d8w,
};

pub const Model = enum {
EOF

cat chip-list.json | jq -r '.data[] | select(.["Part NO."] | startswith("CH32V")) | ["    ", (.["Part NO."] | ascii_downcase), ", // ", .Flash, " / ", .SRAM, " / ", .Freq, " / ", .Package, " (", .GPIO, " GPIO)"] | join("")' >>"$OUTPUT_FILE"

cat <<EOF >>"$OUTPUT_FILE"

    pub fn series(self: Model) Series {
        return switch (self) {
EOF

declare -A model_series

while IFS='|' read -r key value; do
  key=$(echo "$key" | sed -e 's/ch32v20[0-9]/ch32v20x/g' -e 's/ch32v30[0-9]/ch32v30x/g')
  model_series["$key"]+=".$value, "
done < <(cat chip-list.json | jq -r '.data[] | select(.["Part NO."] | startswith("CH32V")) | [(.["url"] | split("/")[-1] | split(".")[0]), "|", .["Part NO."] ] |  join("") | ascii_downcase' | sort)

for key in $(printf "%s\n" "${!model_series[@]}" | sort); do
  formatted_value=$(echo "${model_series[$key]}" | sed 's/, $//')
  echo "            ${formatted_value} => .$key," >>"$OUTPUT_FILE"
done

cat <<EOF >>"$OUTPUT_FILE"
        };
    }

    pub fn class(self: Model) Class {
        return switch (self) {
EOF

# Specific classification abbreviations (from the reference manual):
# CH32V20x_D6: CH32V203F6, CH32V203G6, CH32V203F8, CH32V203G8, CH32V203K8, CH32V203C6 and CH32V203C8.
# CH32V20x_D8: CH32V203RB.
# CH32V20x_D8W: CH32V208GB, CH32V208CB, CH32V208RB and CH32V208WB.
# CH32V30x_D8: CH32V303CB, CH32V303RB, CH32V303RC and CH32V303VC.
# CH32V30x_D8C: CH32V305FB, CH32V305RB, CH32V305GB, CH32V307RC, CH32V307WC and CH32V307VC.
d6="ch32v203f6 ch32v203g6 ch32v203f8 ch32v203g8 ch32v203k8 ch32v203c6 ch32v203c8"
d8="ch32v203rb ch32v303cb ch32v303rb ch32v303rc ch32v303vc"
d8w="ch32v208gb ch32v208cb ch32v208rb ch32v208wb"
d8c="ch32v305fb ch32v305rb ch32v305gb ch32v307rc ch32v307wc ch32v307vc"

declare -A model_class

while read -r key; do
  key_trimmed=$(echo "$key" | sed 's/..$//')
  if [[ $d6 == *"$key_trimmed"* ]]; then
    model_class["d6"]+=".$key, "
  elif [[ $d8 == *"$key_trimmed"* ]]; then
    model_class["d8"]+=".$key, "
  elif [[ $d8w == *"$key_trimmed"* ]]; then
    model_class["d8w"]+=".$key, "
  elif [[ $d8c == *"$key_trimmed"* ]]; then
    model_class["d8c"]+=".$key, "
  fi

done < <(cat chip-list.json | jq -r '.data[] | select(.["Part NO."] | startswith("CH32V")) | .["Part NO."] | ascii_downcase' | sort)

for key in $(printf "%s\n" "${!model_class[@]}" | sort); do
  formatted_value=$(echo "${model_class[$key]}" | sed 's/, $//')
  echo "            ${formatted_value} => .${key}," >>"$OUTPUT_FILE"
done

cat <<EOF >>"$OUTPUT_FILE"
            else => .none,
        };
    }

    pub fn linkScript(self: Model, b: *std.Build) []const u8 {
        const name = switch (self) {
EOF

declare -A model_link_script

while IFS='|' read -r key value; do
  model_link_script["$key"]+=".$value, "
done < <(cat chip-list.json | jq -r '.data[] | select(.["Part NO."] | startswith("CH32V")) | [ .Flash, "_", .SRAM, "|", (.["Part NO."] | ascii_downcase) ] | join("")' | sort)

for key in $(printf "%s\n" "${!model_link_script[@]}" | sort -n -t'|' -k1); do
  formatted_value=$(echo "${model_link_script[$key]}" | sed 's/, $//')
  flash=$(echo "$key" | cut -d"_" -f1)
  sram=$(echo "$key" | cut -d"_" -f2)

  echo "            ${formatted_value} => \"ch32v_${flash}_${sram}.ld\"," >>"$OUTPUT_FILE"
done

cat <<EOF >>"$OUTPUT_FILE"
        };

        return b.dupe(name);
    }

    pub fn target(self: Model) std.Target.Query {
        return self.series().target();
    }

    pub fn string(self: Model) []const u8 {
        return @tagName(self);
    }
};
EOF
